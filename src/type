algebra.cpp:21:	this->setMinimumHeight(500);
algebra.cpp:22:	this->setMinimumWidth(900);
algebra.cpp:25:	this->setCentralWidget(tabs);
algebra.cpp:36:	c_dock_vars->setFeatures(QDockWidget::DockWidgetFloatable|QDockWidget::DockWidgetMovable);
algebra.cpp:37:	this->addDockWidget(static_cast<Qt::DockWidgetArea>(2), c_dock_vars);
algebra.cpp:41:	c_exp->setAnalitza(c_results->analitza());
algebra.cpp:42:	c_variables->setAnalitza(c_results->analitza());
algebra.cpp:43:	c_dock_vars->setWidget(c_variables);
algebra.cpp:45:	tabs->addTab(console, i18n("&Console"));
algebra.cpp:46:	console->setLayout(c_layo);
algebra.cpp:47:	c_layo->addWidget(c_results);
algebra.cpp:48:	c_layo->addWidget(c_exp);
algebra.cpp:58:	QMenu *c_menu = menuBar()->addMenu(i18n("C&onsole"));
algebra.cpp:59:	c_menu->addAction(i18n("&New"), c_results, SLOT(clear()), QKeySequence::New);
algebra.cpp:60:	c_menu->addAction(i18n("&Load Script"), this, SLOT(loadScript()), Qt::CTRL+Qt::Key_L);
algebra.cpp:61:	c_menu->addAction(i18n("&Save Log"), this, SLOT(saveLog()), QKeySequence::Save);
algebra.cpp:62:	c_menu->addSeparator();
algebra.cpp:63:	c_menu->addAction(i18n("&Quit"), this, SLOT(close()), Qt::CTRL+Qt::Key_Q);
algebra.cpp:72:	b_tools->setTabPosition(QTabWidget::South);
algebra.cpp:74:	this->addDockWidget(static_cast<Qt::DockWidgetArea>(2), b_dock_funcs);
algebra.cpp:77:	b_funcs->headerItem()->setText(0, i18n("Color"));
algebra.cpp:78:	b_funcs->headerItem()->setText(1, i18n("Function"));
algebra.cpp:79:	b_funcs->header()->setResizeMode(0, QHeaderView::ResizeToContents);
algebra.cpp:80:	b_funcs->setSelectionMode(QAbstractItemView::SingleSelection);
algebra.cpp:81:	b_funcs->setRootIsDecorated(false);
algebra.cpp:82:	b_funcs->setSortingEnabled(false);
algebra.cpp:83:	b_funcs->clear();
algebra.cpp:84:	b_tools->addTab(b_funcs, i18n("List"));
algebra.cpp:88:	b_tools->addTab(b_funced, i18n("&Add"));
algebra.cpp:90:	b_dock_funcs->setWidget(b_tools);
algebra.cpp:91:	b_dock_funcs->setFeatures(QDockWidget::DockWidgetFloatable | QDockWidget::DockWidgetMovable);
algebra.cpp:92:	tabs->addTab(grafic, i18n("&2D Graph"));
algebra.cpp:103:	QMenu *b_menu = menuBar()->addMenu(i18n("2&D Graph"));
algebra.cpp:105:	b_actions[0] = b_menu->addAction(i18n("&Grid"), this, SLOT(toggleSquares()));
algebra.cpp:106:	b_actions[1] = b_menu->addAction(i18n("&Save"), this, SLOT(saveGraph()));
algebra.cpp:107:	b_menu->addSeparator()->setText(i18n("Resolution"));
algebra.cpp:108:	b_actions[2] = b_menu->addAction(i18n("Poor"), this, SLOT(set_res_low()));
algebra.cpp:109:	b_actions[3] = b_menu->addAction(i18n("Normal"), this, SLOT(set_res_std()));
algebra.cpp:110:	b_actions[4] = b_menu->addAction(i18n("Fine"), this, SLOT(set_res_fine()));
algebra.cpp:111:	b_actions[5] = b_menu->addAction(i18n("Very Fine"), this, SLOT(set_res_vfine()));
algebra.cpp:114:	res->addAction(b_actions[2]);
algebra.cpp:115:	res->addAction(b_actions[3]);
algebra.cpp:116:	res->addAction(b_actions[4]);
algebra.cpp:117:	res->addAction(b_actions[5]);
algebra.cpp:119:	b_actions[0]->setCheckable(true);
algebra.cpp:120:	b_actions[0]->setChecked(true);
algebra.cpp:121:	b_actions[2]->setCheckable(true);
algebra.cpp:122:	b_actions[3]->setCheckable(true);
algebra.cpp:123:	b_actions[3]->setChecked(true);
algebra.cpp:124:	b_actions[4]->setCheckable(true);
algebra.cpp:125:	b_actions[5]->setCheckable(true);
algebra.cpp:134:	tridim->setLayout(t_layo);
algebra.cpp:135:	tabs->addTab(tridim, i18n("&3D Graph"));
algebra.cpp:136:	t_layo->addWidget(grafic3d);
algebra.cpp:137:	t_layo->addWidget(t_exp);
algebra.cpp:143:	QMenu *t_menu = menuBar()->addMenu(i18n("3D &Graph"));
algebra.cpp:145:	t_actions[0] = t_menu->addAction(i18n("&Transparency"), this, SLOT(toggleTransparency()));
algebra.cpp:146:	t_actions[1] = t_menu->addAction(i18n("&Save"), this, SLOT(save3DGraph()));
algebra.cpp:147:	t_menu->addSeparator()->setText(i18n("Type"));
algebra.cpp:148:	t_actions[2] = t_menu->addAction(i18n("Dots"), this, SLOT(set_dots()));
algebra.cpp:149:	t_actions[3] = t_menu->addAction(i18n("Lines"), this, SLOT(set_lines()));
algebra.cpp:150:	t_actions[4] = t_menu->addAction(i18n("Solid"), this, SLOT(set_solid()));
algebra.cpp:153:	t_type->addAction(t_actions[2]);
algebra.cpp:154:	t_type->addAction(t_actions[3]);
algebra.cpp:155:	t_type->addAction(t_actions[4]);
algebra.cpp:157:	t_actions[0]->setCheckable(true);
algebra.cpp:158:	t_actions[2]->setCheckable(true);
algebra.cpp:159:	t_actions[3]->setCheckable(true);
algebra.cpp:160:	t_actions[4]->setCheckable(true);
algebra.cpp:161:	t_actions[4]->setChecked(true);
algebra.cpp:166:	QMenu *h_menu = menuBar()->addMenu(i18n("&Help"));
algebra.cpp:167:// 	h_menu->addAction(i18n("&Help"), c_results, SLOT(clear()));
algebra.cpp:168:	h_menu->addSeparator();
algebra.cpp:169:	h_menu->addAction(i18n("&About"), this, SLOT(about()));
algebra.cpp:176:	grafic3d->setFunc(t_exp->text());
algebra.cpp:177:	grafic3d->setFocus();
algebra.cpp:183:	if(!b_funced->editing()) {
algebra.cpp:184:		grafic->addFunction(function(b_funced->text(), b_funced->color(), true, b_funced->isMathML()));
algebra.cpp:185:		grafic->setSelected(b_funced->text());
algebra.cpp:188:		item->setFlags(Qt::ItemIsSelectable| Qt::ItemIsUserCheckable| Qt::ItemIsEnabled| Qt::ItemIsTristate);
algebra.cpp:190:		grafic->editFunction(b_funcs->currentItem()->text(1),
algebra.cpp:191:				     function(b_funced->text(), b_funced->color(), true, b_funced->isMathML()));
algebra.cpp:192:// 		grafic->setSelected(b_funcs->currentItem()->text(1));
algebra.cpp:194:		item = b_funcs->currentItem();
algebra.cpp:197:	ico.fill(b_funced->color());
algebra.cpp:199:	item->setIcon(0, ico);
algebra.cpp:200:	item->setText(1, b_funced->text());
algebra.cpp:201:	item->setTextColor(1, b_funced->color());
algebra.cpp:202:	item->setCheckState(0, Qt::Checked);
algebra.cpp:203:	b_funced->setEditing(false);
algebra.cpp:204:	b_funced->clear();
algebra.cpp:205:	b_tools->setCurrentIndex(0);
algebra.cpp:206:	grafic->setFocus();
algebra.cpp:211:	b_tools->setTabText(1, i18n("&Editing"));
algebra.cpp:212:	b_tools->setCurrentIndex(1);
algebra.cpp:213:	b_funced->setText(b_funcs->currentItem()->text(1));
algebra.cpp:214:	b_funced->setEditing(true);
algebra.cpp:215:	b_funced->setFocus();
algebra.cpp:221:		b_tools->setTabText(1, i18n("&Add"));
algebra.cpp:223:		b_funced->setEditing(false);
algebra.cpp:224:		b_funced->setFocus();
algebra.cpp:231:	e.setAnalitza(c_results->analitza());
algebra.cpp:232:	e.setVar(c_variables->currentItem()->text(0));
algebra.cpp:235:		c_results->analitza()->m_vars->modify(c_variables->currentItem()->text(0), e.val());
algebra.cpp:236:	c_variables->updateVariables();
algebra.cpp:241:	if(!c_exp->text().isEmpty()){
algebra.cpp:242:		c_exp->setCorrect(c_results->addOperation(c_exp->text(), c_exp->isMathML()));
algebra.cpp:243:		c_exp->selectAll();
algebra.cpp:249:	c_exp->insertPlainText(item->toolTip());
algebra.cpp:250:	c_exp->setFocus();
algebra.cpp:255:	statusBar()->showMessage(msg);
algebra.cpp:262:		c_results->loadScript(path);
algebra.cpp:269:		c_results->saveLog(path);
algebra.cpp:273:void QAlgebra::set_res_low()	{ grafic->setResolution(416); }
algebra.cpp:274:void QAlgebra::set_res_std()	{ grafic->setResolution(832); }
algebra.cpp:275:void QAlgebra::set_res_fine()	{ grafic->setResolution(1664);}
algebra.cpp:276:void QAlgebra::set_res_vfine()	{ grafic->setResolution(3328);}
algebra.cpp:278:void QAlgebra::set_dots()	{ grafic3d->setMethod(Q3DGraph::Dots);  }
algebra.cpp:279:void QAlgebra::set_lines()	{ grafic3d->setMethod(Q3DGraph::Lines); }
algebra.cpp:280:void QAlgebra::set_solid()	{ grafic3d->setMethod(Q3DGraph::Solid); }
algebra.cpp:284:	grafic3d->setTransparency(!grafic3d->transparency());
algebra.cpp:291:		grafic3d->toPixmap().save(path, "PNG");
algebra.cpp:296:	grafic->setSquares(!grafic->squares());
algebra.cpp:303:		grafic->toImage(path);
algebra.cpp:308:	grafic->setSelected(current->text(1));
algebra.cpp:313:	QColor c(item->icon(0).pixmap(1,1).toImage().pixel(0,0));
algebra.cpp:314:	grafic->setShown(function(item->text(1), c), item->checkState(0) == Qt::Checked);
algebra.cpp:319:	c_dock_vars->hide();
algebra.cpp:320:	b_dock_funcs->hide();
algebra.cpp:323:			c_dock_vars->show();
algebra.cpp:324:			c_dock_vars->raise();
algebra.cpp:325:			c_exp->setFocus();
algebra.cpp:328:			b_dock_funcs->show();
algebra.cpp:329:			b_dock_funcs->raise();
algebra.cpp:330:// 			b_add->setFocus();
algebra.cpp:333:			t_exp->setFocus();
algebra.cpp:344:			     i18n("KAlgebra (c) 2005-2006\n"
analitza.cpp:18: *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
analitza.cpp:92:					c->appendBranch(branch(n.toElement()));
analitza.cpp:98:			QList<Object*>::iterator i=c->m_params.begin();
analitza.cpp:108:			num->setValue(elem);
analitza.cpp:118:				var->setFunction(elem.attribute("type")=="function");
analitza.cpp:141:	Q_ASSERT(root!=NULL && root->type()!=Object::none);
analitza.cpp:145:	switch(root->type()) {
analitza.cpp:155:			if(m_vars->contains(a->name()))
analitza.cpp:156:				ret = calc(m_vars->value(a->name()));
analitza.cpp:157:			else if(a->isFunction())
analitza.cpp:158:				m_err << i18n("The function <em>%1</em> doesn't exist").arg(a->name());
analitza.cpp:160:				m_err << i18n("The variable <em>%1</em> doesn't exist").arg(a->name());
analitza.cpp:176:	if(c->containerType() > 100)
analitza.cpp:179:	if(c->m_params.count()==0) {
analitza.cpp:180:		m_err << i18n("Empty container: %1").arg(c->containerType());
analitza.cpp:184:	if(c->m_params[0]->type() == Object::oper)
analitza.cpp:185:		op = (Operator*) c->m_params[0];
analitza.cpp:187:	if(op!= NULL && op->operatorType()==Object::sum)
analitza.cpp:189:	else if(op!= NULL && op->operatorType()==Object::product)
analitza.cpp:191:	else switch(c->containerType()) {
analitza.cpp:198:			if(c->m_params[0]->type() == Object::variable) {
analitza.cpp:199:				Ci* var= (Ci*) c->m_params[0];
analitza.cpp:201:				if(var->isFunction())
analitza.cpp:204:					ret = calc(c->m_params[0]);
analitza.cpp:206:				QList<Object*>::iterator it = c->m_params.begin();
analitza.cpp:207:				for(; it!=c->m_params.end(); it++) {
analitza.cpp:212:					} else if((*it)->type() != Object::oper) {
analitza.cpp:219:				} else if(op->nparams()>-1 && numbers.count()!=op->nparams() && op->operatorType()!=Object::minus) {
analitza.cpp:220:					m_err << i18n("Too much operators for <em>%1</em>").arg(op->operatorType());
analitza.cpp:222:				} else if(numbers.count()>=1 && op->type()==Object::oper) {
analitza.cpp:229:							reduce(op->operatorType(), &ret, *it, false);
analitza.cpp:233:						reduce(op->operatorType(), &ret, 0., true);
analitza.cpp:243:			if(c->m_params.count()<=1) {
analitza.cpp:248:			Ci *var = (Ci*) c->m_params[0];
analitza.cpp:250:			switch(c->m_params[1]->type()) {
analitza.cpp:252:					m_vars->modify(var->name(), new Ci(c->m_params[1]));
analitza.cpp:255:					m_vars->modify(var->name(), new Cn(c->m_params[1]));
analitza.cpp:258:					m_vars->modify(var->name(), new Operator(c->m_params[1]));
analitza.cpp:261:					m_vars->modify(var->name(), new Container(c->m_params[1]));
analitza.cpp:269:			ret = calc(c->m_params[c->m_params.count()-1]);
analitza.cpp:284:	bool existed=m_vars->contains(var);
analitza.cpp:285:	m_vars->rename(var, var+"_"); //We save the var value
analitza.cpp:286:	m_vars->modify(var, new Cn(0.));
analitza.cpp:287:	c = (Cn*) m_vars->value(var);
analitza.cpp:294:		m_vars->rename(var+"_", var); //We restore the var value
analitza.cpp:296:		m_vars->destroy(var);
analitza.cpp:308:	bool existed=m_vars->contains(var);
analitza.cpp:309:	m_vars->rename(var, var+"_"); //We save the var value
analitza.cpp:310:	m_vars->modify(var, new Cn(0.));
analitza.cpp:311:	c = (Cn*) m_vars->value(var);
analitza.cpp:318:		m_vars->rename(var+"_", var); //We restore the var value
analitza.cpp:320:		m_vars->destroy(var);
analitza.cpp:329:		if(c->type()==Object::container && c->containerType()==Object::uplimit && c->m_params[0]->type()==Object::value)
analitza.cpp:330:			return Cn(c->m_params[0]);
analitza.cpp:341:		if(c->type()==Object::container && c->containerType()==Object::downlimit && c->m_params[0]->type()==Object::value)
analitza.cpp:342:			return Cn(c->m_params[0]);
analitza.cpp:351:	if(!m_vars->contains(func.name()))
analitza.cpp:354:	Container *c = (Container*) m_vars->value(func.name());
analitza.cpp:355:	if(c->type()==Object::container && c->containerType() == Object::lambda)
analitza.cpp:366:	if(funct.type()!=Object::variable || !funct.isFunction() || !m_vars->contains(funct.name())) {
analitza.cpp:376:	Container *function = (Container*) m_vars->value(funct.name());
analitza.cpp:378:	QStringList var = function->bvarList();
analitza.cpp:381:		m_vars->rename(var[i], var[i]+"_"); //We save the var value
analitza.cpp:382:		m_vars->modify(var[i], n.m_params[i+1]);
analitza.cpp:385:	ret=calc(function->m_params[var.count()]);
analitza.cpp:388:		m_vars->remove(var[i]);
analitza.cpp:389:		m_vars->rename(var[i]+"_", var[i]); //We save the var value
analitza.cpp:398:	double a=ret->value(), b=oper.value(), c;
analitza.cpp:412:			a = unary ? -a : a-b;
analitza.cpp:435:			for(a=1.; b>1.; b--)
analitza.cpp:487:			a=0.5*(log(1.+1./a)-log(1.-1./a));
analitza.cpp:490:			a=log(a+sqrt(a-1.)*sqrt(a+1.));
analitza.cpp:508:			a= a>=0. ? a : -a;
analitza.cpp:539:			a= abs(a-b)<0.001? 1.0 : 0.0;
analitza.cpp:599:	ret->setValue(a);
analitza.cpp:605:	if(m_tree != NULL && c->type()==Object::container) {
analitza.cpp:606:		c = (Container*) c->m_params[0];
analitza.cpp:608:		if(c->type()==Object::container)
analitza.cpp:609:			return c->bvarList();
analitza.cpp:620:		return m_tree->toMathML();
analitza.cpp:628:		return m_tree->toString();
analitza.cpp:644:	Q_ASSERT(root!=NULL && root->type()!=Object::none);
analitza.cpp:647:		if(root->type() !=Object::oper) {
analitza.cpp:652:	} else if(root->isContainer()) {
analitza.cpp:654:		QList<Object*>::iterator it = c->m_params.begin();
analitza.cpp:655:		switch(c->firstOperator().operatorType()) {
analitza.cpp:657:				for(; it!=c->m_params.end(); ++it) {
analitza.cpp:659:					if((*it)->type() == Object::value) {
analitza.cpp:661:						if(n->value()==0.) { //0*exp=0
analitza.cpp:665:						}/* else if(n->value()==1.) { //Identity member, FIXME 1*exp=exp
analitza.cpp:667:							c->m_params.erase(it);
analitza.cpp:674:				for(; it!=c->m_params.end(); it++) {
analitza.cpp:676:					if((*it)->type() == Object::value) {
analitza.cpp:678:						if(n->value()==0.) { //0+-exp=exp
analitza.cpp:680:							c->m_params.erase(it);
analitza.cpp:686:				for(; it!=c->m_params.end(); it++)
analitza.cpp:698:	switch(o->type()) {
analitza.cpp:704:			QList<Object*>::iterator it = c->m_params.begin();
analitza.cpp:706:			for(; it!=c->m_params.end(); it++)
console.cpp:28:	QFont f = item->font();
console.cpp:30:		a.m_vars->modify("ans", new Cn(res));
console.cpp:31:		item->setText(QString("%1 = %2").arg(a.toString()).arg(res.value(), 0, 'g', 12));
console.cpp:32:// 		item->setText(QString("%1\n%2").arg(op).arg(res.value(), 0, 'g', 12));
console.cpp:33:		item->setToolTip(QString::number(res.value(), 'g', 12));
console.cpp:35:			item->setBackgroundColor(QColor(233,233,222));
console.cpp:37:			item->setBackgroundColor(QColor(250,250,250));
console.cpp:39:		item->setText(QString("%1\nError: %2").arg(op).arg(a.m_err.join("\n")));
console.cpp:40:		item->setBackgroundColor(QColor(255,222,222));
console.cpp:41:		item->setTextAlignment(Qt::AlignRight);
console.cpp:43:		item->setFont(f);
console.cpp:46:	qApp->processEvents();
console.cpp:47:	this->verticalScrollBar()->setValue(this->verticalScrollBar()->maximum());
console.cpp:82:			for(int i=0; i<this->count(); i++)
console.cpp:83:				out << this->item(i)->text() << endl;
console.cpp:98:	headerItem()->setText(0, i18n("Name"));
console.cpp:99:	headerItem()->setText(1, i18n("Value"));
console.cpp:101:	header()->setResizeMode(0, QHeaderView::ResizeToContents);
console.cpp:114:		QHash<QString, Object*>::const_iterator it = a->m_vars->begin();
console.cpp:115:		for(; it != a->m_vars->end(); ++it) {
console.cpp:117:			item->setText(0, it.key());
console.cpp:118:			item->setText(1, it.value()->toString());
container.cpp:18: *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
container.cpp:35:Container::Container(const Object *o) : Object(o->type())
container.cpp:40:		m_cont_type = c->containerType();
container.cpp:42:		m_params = c->copyParams();
container.cpp:54:		if(m_params[i]->type()==Object::oper) {
container.cpp:80:		if(m_params[i]->type() == Object::oper)
container.cpp:82:		else if(m_params[i]->type() == Object::variable) {
container.cpp:84:			if(b->isFunction())
container.cpp:86:			ret << b->toString();
container.cpp:87:		} else if(m_params[i]->type() == Object::container) {
container.cpp:89:			QString s = c->toString();
container.cpp:90:			Operator child_op = c->firstOperator();
container.cpp:91:			if(op!=NULL && op->weight()>child_op.weight() && child_op.nparams()!=1)
container.cpp:94:			if(c->containerType() == Object::bvar) {
container.cpp:98:						s += dl->toString();
container.cpp:101:						s += ul->toString();
container.cpp:105:			if(c->containerType()!=Object::uplimit && c->containerType()!=Object::downlimit)
container.cpp:108:			ret << m_params[i]->toString();
container.cpp:128:			else switch(op->operatorType()) {
container.cpp:140:						toret += "-"+ret[0];
container.cpp:142:						toret += ret.join("-");
container.cpp:148:					toret += QString("%1(%2)").arg(op->toString()).arg(ret.join(", "));
container.cpp:152:		case Object::uplimit: //x->(n1..n2) is put at the same time
container.cpp:156:			toret += ret.join("->")+"->";
container.cpp:170:		switch((*it)->type()) {
container.cpp:212:		if(c->containerType() == Object::bvar)
container.cpp:213:			bvars.append(((Ci*)c->m_params[0])->name());
container.cpp:223:		if(c->type()==Object::container && c->containerType()==Object::uplimit && c->m_params[0]->type()==Object::value)
container.cpp:224:			return (Container*) c->m_params[0];
container.cpp:233:		if(c->type()==Object::container && c->containerType()==Object::downlimit && c->m_params[0]->type()==Object::value)
container.cpp:234:			return (Container*) c->m_params[0];
container.cpp:247:			switch((*i)->type()) {
container.cpp:254:					ret |= c->hasVars();
container.cpp:280:	switch(root->type()) {
container.cpp:283:			qDebug() << qPrintable(s) << "| cont: " << (int) c->containerType();
container.cpp:284:			for(int i=0; i<c->m_params.count(); i++)
container.cpp:285:				objectWalker(c->m_params[i], ind+1);
container.cpp:290:			qDebug() << qPrintable(s) << "| num: " << num->value();
container.cpp:294:			qDebug() << qPrintable(s) << "| operator: " << op->operatorType();
container.cpp:298:			qDebug() << qPrintable(s) << "| variable: " << var->name() << "Func:" << var->isFunction();
container.cpp:301:			qDebug() << qPrintable(s) << "| dunno: " << (int) root->type();
container.cpp:319:		qDebug("%s%s(%s) -- %d", qPrintable(a), qPrintable(in.toElement().tagName()), qPrintable(in.toElement().text()), in.childNodes().length());
function.cpp:54:	ret = func->setTextMML(funct);
function.cpp:68:	QStringList lambdas = func->bvarList();
function.cpp:95:	double l_lim=viewport.left()-1., r_lim=viewport.right()+1., x=0.;
function.cpp:97:	unsigned int resolucio=0, ample=static_cast<unsigned int>(-l_lim+r_lim);
function.cpp:100:	resolucio -= ample;
function.cpp:102:	double inv_res= (double) (-l_lim+r_lim)/resolucio;
function.cpp:106:		int cacho = static_cast<int>(round(resolucio/(-l_lim+r_lim)));
function.cpp:110:			for(i=(viewport.width())*cacho; i>(m_last_viewport.right()-viewport.right());i--)
function.cpp:111:				points[i] = points[i+cacho*(viewport.right()-m_last_viewport.right())];
function.cpp:117:			for(i=0;i<(viewport.width()-(viewport.left()-m_last_viewport.left()))*cacho;i++)
function.cpp:118:				points[i]=points[i+(viewport.left()-m_last_viewport.left())*cacho];
function.cpp:122:	func->m_vars->modify("x", new Cn(0.));
function.cpp:123:	Cn *vx = (Cn*) func->m_vars->value("x");
function.cpp:126:		vx->setValue(x);
function.cpp:127:		double y = func->calculate().value();
function.cpp:138:	if(viewport.top()==m_last_viewport.top() && viewport.bottom()==m_last_viewport.bottom() && max_res==m_last_max_res || max_res<=static_cast<unsigned int>(-viewport.height()))
function.cpp:146:	double t_lim=viewport.top()+1, b_lim=viewport.bottom()-1;
function.cpp:148:	unsigned int resolucio=0, ample=static_cast<unsigned int>(-b_lim+t_lim);
function.cpp:152:	resolucio -= ample;
function.cpp:154:	double inv_res= (double) ( -b_lim+t_lim)/resolucio;
function.cpp:158:		int cacho = round(resolucio/(-b_lim+t_lim));
function.cpp:162:			b_lim= m_last_viewport.top()-1;
function.cpp:163:			for(i=0;i<(viewport.height()-(viewport.height()+m_last_viewport.top()))*cacho;i++){
function.cpp:164:// 				qDebug("%d>=%d", resolucio, i+(m_last_viewport.top()-viewport.top())*cacho);
function.cpp:165:				points[i]=points[i+(m_last_viewport.top()-viewport.top())*cacho];
function.cpp:172:	for(y=t_lim; y>=b_lim; y-=inv_res) {
function.cpp:173:		func->m_vars->modify("y", new Cn(y));
function.cpp:174:		x = func->calculate().value();
function.cpp:186:	Q_ASSERT(func->tree() != NULL && func->tree()->isContainer());
function.cpp:192:	Cn ulimit = func->uplimit(func->tree()->m_params[0]), dlimit=func->downlimit(func->tree()->m_params[0]);
function.cpp:194:// 	objectWalker(func->tree());
function.cpp:216:	double inv_res= (double) (ulimit.value()-dlimit.value())/resolucio;
function.cpp:217:	func->m_vars->modify("q", 0.);
function.cpp:218:	Cn *varth = (Cn*) func->m_vars->value("q");
function.cpp:221:		varth->setValue(th);
function.cpp:222:		r = func->calculate().value();
function.cpp:236:	if(func->m_tree!=NULL && !m_exp.isEmpty()) {
function.cpp:238:			func->m_vars->modify("y", dp.y());
function.cpp:239:			dp.setX(func->calculate().value());
function.cpp:247:			Cn ulimit = func->uplimit(func->tree()->m_params[0]), dlimit=func->downlimit(func->tree()->m_params[0]);
function.cpp:255:				th -= 2.*pi;*/
function.cpp:258:				func->m_vars->modify("q", th);
function.cpp:259:				r = func->calculate().value();
function.cpp:261:				dist = (dp-p);
function.cpp:264:				func->m_vars->modify("q", th+2.*pi);
function.cpp:265:				r = func->calculate().value();
function.cpp:267:				dist = (dp-p);
function.cpp:275:			func->m_vars->modify("q", th);
function.cpp:276:			r = func->calculate().value();
function.cpp:280:			func->m_vars->modify(QString("x"), dp.x());
function.cpp:281:			dp.setY(func->calculate().value());
kfunctionedit.cpp:11:	this->setWindowTitle(i18n("Add/Edit a function"));
kfunctionedit.cpp:13:	buttonBox->setOrientation(Qt::Horizontal);
kfunctionedit.cpp:14:	buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok);
kfunctionedit.cpp:18:// 	this->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);
kfunctionedit.cpp:19:// 	this->setFixedWidth(400);
kfunctionedit.cpp:20:// 	this->setFixedHeight(350);
kfunctionedit.cpp:23:	topLayout->setMargin(2);
kfunctionedit.cpp:24:	topLayout->setSpacing(5);
kfunctionedit.cpp:27:	m_func->setAns("x");
kfunctionedit.cpp:32:	m_valid->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
kfunctionedit.cpp:35:	m_color->setColor(QColor(0,150,0));
kfunctionedit.cpp:39:	m_graph->setViewPort(QRect(QPoint(-9, 5), QPoint(9, -5)));
kfunctionedit.cpp:40:	m_graph->setResolution(200);
kfunctionedit.cpp:41:	m_graph->setFocusPolicy(Qt::NoFocus);
kfunctionedit.cpp:42:	m_graph->addFunction(function(m_func->text(), m_color->color(), true));
kfunctionedit.cpp:43:	m_graph->setMouseTracking(false);
kfunctionedit.cpp:44:	m_graph->setFramed(true);
kfunctionedit.cpp:45:	m_graph->setReadOnly(true);
kfunctionedit.cpp:46:	m_graph->setSquares(false);
kfunctionedit.cpp:54:	topLayout->addWidget(m_func);
kfunctionedit.cpp:55:	topLayout->addWidget(m_color);
kfunctionedit.cpp:56:	topLayout->addWidget(m_valid);
kfunctionedit.cpp:57:	topLayout->addWidget(m_graph);
kfunctionedit.cpp:58:	topLayout->addLayout(m_butts);
kfunctionedit.cpp:60:	m_butts->addWidget(m_ok);
kfunctionedit.cpp:61:	m_butts->addWidget(m_clear);
kfunctionedit.cpp:63:	m_func->setFocus();
kfunctionedit.cpp:64:	m_ok->setEnabled(false);
kfunctionedit.cpp:73:	m_func->setText(QString::null);
kfunctionedit.cpp:79:	m_func->setText(newText);
kfunctionedit.cpp:80:	m_func->document()->setModified(true);
kfunctionedit.cpp:85:	m_color->setColor(newColor);
kfunctionedit.cpp:86:	m_graph->editFunction(0)->setColor(newColor);
kfunctionedit.cpp:87:	m_graph->forceRepaint();
kfunctionedit.cpp:92:	setColor(m_color->color());
kfunctionedit.cpp:98:	QString funct = m_func->text();
kfunctionedit.cpp:100:	if(m_func->text().isEmpty()) {
kfunctionedit.cpp:101:		m_func->setCorrect(true);
kfunctionedit.cpp:102:		m_ok->setEnabled(false);
kfunctionedit.cpp:103:		m_valid->setText(QString::null);
kfunctionedit.cpp:107:	if(!m_func->isMathML()) {
kfunctionedit.cpp:112:			a->setTextMML(funct);
kfunctionedit.cpp:114:			a->m_err << i18n("From parser:") << e.error();
kfunctionedit.cpp:116:		a->setTextMML(funct);
kfunctionedit.cpp:118:	if(a->isCorrect()) {
kfunctionedit.cpp:119:		QStringList bvl = a->bvarList();
kfunctionedit.cpp:121:		a->m_vars->modify(var, 0.);
kfunctionedit.cpp:122:		m_valid->setText(QString("<b style='color:#090'>f:=%2</b>").arg(a->toString()));
kfunctionedit.cpp:123:		a->calculate();
kfunctionedit.cpp:126:	if(!a->isCorrect()) {
kfunctionedit.cpp:127:		m_valid->setText(i18n("<b style='color:red'>WRONG</b>"));
kfunctionedit.cpp:128:		m_graph->editFunction(0, function());
kfunctionedit.cpp:129:		m_graph->forceRepaint();
kfunctionedit.cpp:130:		m_valid->setToolTip(a->m_err.join("\n"));
kfunctionedit.cpp:133:		m_valid->setToolTip(QString::null);
kfunctionedit.cpp:134:		m_graph->editFunction(0, function(m_func->toPlainText(), m_color->color(), true));
kfunctionedit.cpp:138:	m_func->setCorrect(m_correct);
kfunctionedit.cpp:139:	m_ok->setEnabled(m_correct);
kfunctionedit.cpp:171:	if(pos==-1) {
kfunctionedit.cpp:175:		setCurrentIndex(count()-1);
kvaredit.cpp:10:	this->setWindowTitle(i18n("Add/Edit a variable"));
kvaredit.cpp:11:	this->setModal(modal);
kvaredit.cpp:12:	this->setMinimumSize(200, 200);
kvaredit.cpp:15:	buttonBox->setOrientation(Qt::Horizontal);
kvaredit.cpp:16:	buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok);
kvaredit.cpp:32:	m_opt_calc->setChecked(true);
kvaredit.cpp:35:	vbox->addWidget(m_opt_calc);
kvaredit.cpp:36:	vbox->addWidget(m_opt_exp);
kvaredit.cpp:37:	buttons->setLayout(vbox);
kvaredit.cpp:39:	topLayout->addWidget(m_exp);
kvaredit.cpp:40:	topLayout->addWidget(m_valid);
kvaredit.cpp:41:	topLayout->addWidget(buttons);
kvaredit.cpp:42:	topLayout->addWidget(buttonBox);
kvaredit.cpp:44:	m_exp->setFocus();
kvaredit.cpp:52:	this->setWindowTitle(i18n("Edit '%1' value").arg(newVar));
kvaredit.cpp:55:		m_exp->setText("not available");
kvaredit.cpp:63:	QString expres = m_exp->text();
kvaredit.cpp:64:	if(!m_exp->isMathML()) {
kvaredit.cpp:72:	if(m_opt_calc->isChecked())
kvaredit.cpp:89:	QString expr=m_exp->text();
kvaredit.cpp:90:	if(!m_exp->isMathML()) {
kvaredit.cpp:96:	err_num= a.setTextMML(m_exp->text());
kvaredit.cpp:99:			m_valid->setText(i18n("%1:=%2").arg(m_var).arg(m_exp->text()));
kvaredit.cpp:103:				err_num=-1;
kvaredit.cpp:106:				m_valid->setText(i18n("WRONG"));
kvaredit.cpp:107:				m_valid->setToolTip(a.m_err.join("\n"));
kvaredit.cpp:110:				m_valid->setText(i18n("%1 := %2").arg(m_var).arg(val));
kvaredit.cpp:111:				m_valid->setToolTip(QString::null);
kvaredit.cpp:117:	m_exp->setCorrect(m_correct);
kvaredit.cpp:118:	buttonBox->button(QDialogButtonBox::Ok)->setEnabled(m_correct);
moc_algebra.cpp:121:        _id -= 25;
moc_console.cpp:84:        _id -= 6;
moc_console.cpp:148:        _id -= 1;
moc_kfunctionedit.cpp:118:        _id -= 5;
moc_kvaredit.cpp:68:        _id -= 2;
moc_q3dgraph.cpp:66:        _id -= 1;
moc_qexpressionedit.cpp:81:        _id -= 7;
moc_qgraph.cpp:70:        _id -= 2;
object.cpp:18: *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
object.cpp:24:Ci::Ci(Object*o) : Object(o->type())
object.cpp:28:		m_name = c->name();
object.cpp:29:		m_function = c->isFunction();
operator.cpp:108:			return -1;
operator.cpp:171:Operator::Operator(Object *o) : Object(o->type())
operator.cpp:175:		m_optype = c->operatorType();
operator.cpp:249:		if(it!=NULL && it->data(Qt::EditRole).toInt()==op.operatorType()) {
operator.cpp:250:			return item(i,0)->data(Qt::EditRole).toString();
q3dgraph.cpp:19:		default_step(0.15f), default_size(8.0f), zoom(1.0f), punts(NULL), z(-35.),
q3dgraph.cpp:22:	this->setSizePolicy(QSizePolicy::Ignored,QSizePolicy::Ignored);
q3dgraph.cpp:23:	this->setFocusPolicy(Qt::ClickFocus);
q3dgraph.cpp:81:	if(e->button() == Qt::LeftButton){
q3dgraph.cpp:82:		press = e->pos(); keyspressed |= LCLICK;
q3dgraph.cpp:88:	if(e->button() == Qt::LeftButton)
q3dgraph.cpp:95:		QPoint rel = e->pos() - press;
q3dgraph.cpp:97:		graus[2] += -rel.x();
q3dgraph.cpp:100:		this->repaint();
q3dgraph.cpp:102:		press = e->pos();
q3dgraph.cpp:108:	this->renderText(11.0, 0.0, 0.0, "X");
q3dgraph.cpp:109:	this->renderText(0.0, 0.0,-11.0, "Y");
q3dgraph.cpp:110:	this->renderText(0.0, 11.0, 0.0, "Z");
q3dgraph.cpp:114:			glVertex3f(-10.0f, 0.0f, 0.0f);
q3dgraph.cpp:118:			glVertex3f( 0.0f,-10.0f, 0.0f);
q3dgraph.cpp:121:			glVertex3f( 0.0f, 0.0f,-10.0f);
q3dgraph.cpp:131:	if(keyspressed & KEYUP)		graus[0]-=3.f;
q3dgraph.cpp:133:	if(keyspressed & KEYREPAG)	graus[1]-=3.f;
q3dgraph.cpp:135:	if(keyspressed & KEYRIGHT)	graus[2]-=3.f;
q3dgraph.cpp:141:	graus[0] = graus[0]>=360.f ? graus[0]-360.f : graus[0];
q3dgraph.cpp:142:	graus[1] = graus[1]>=360.f ? graus[1]-360.f : graus[1];
q3dgraph.cpp:143:	graus[2] = graus[2]>=360.f ? graus[2]-360.f : graus[2];
q3dgraph.cpp:158:		for(i=0; tefunc && i<(2*mida/step)-1; i++) {
q3dgraph.cpp:159:			for(j=0; tefunc && j<2*mida/step-1; j++) {
q3dgraph.cpp:161:				glVertex3d(i*step-mida, j*step-mida, punts[i][j]);
q3dgraph.cpp:168:		for(i=0; tefunc && i<(2*mida/step)-1; i++) {
q3dgraph.cpp:169:			for(j=0; tefunc && j<2*mida/step-1; j++) {
q3dgraph.cpp:172:				glVertex3d( i*step-mida, j*step - mida, punts[i][j]);
q3dgraph.cpp:173:				glVertex3d( (i?i-1:i)*step-mida, j*step - mida, punts[i?i-1:i][j]);
q3dgraph.cpp:175:				glVertex3d( i*step-mida, j*step - mida, punts[i][j]);
q3dgraph.cpp:176:				glVertex3d( i*step-mida, (j?j-1:j)*step - mida, punts[i][j?j-1:j]);
q3dgraph.cpp:194:		for(i=0; tefunc && i<(2*mida/step-2); i++) {
q3dgraph.cpp:198:			glTranslatef(i*step-mida, -mida, 0);
q3dgraph.cpp:200:			for(j=0; tefunc && j<2*mida/step-1; j++) {
q3dgraph.cpp:202:				glColor4d((i*step-mida)/mida, (j*step-mida)/mida, 1./fabs(log10(5.+punts[i][j])), transf);
q3dgraph.cpp:206:				glColor4d(((i+1)*step-mida)/mida, (j*step-mida)/mida, 1./fabs(log10(5.+punts[i+1][j])), transf);
q3dgraph.cpp:226:	a->setTextMML(func3d);
q3dgraph.cpp:233:		r->start();
q3dgraph.cpp:239:		if(!(*it)->wait(3000)) {
q3dgraph.cpp:241:			(*it)->terminate();
q3dgraph.cpp:259:	a.m_vars->modify("x", 0.);
q3dgraph.cpp:260:	a.m_vars->modify("y", 0.);
q3dgraph.cpp:262:	Cn *x=(Cn*)a.m_vars->value("x"), *y=(Cn*)a.m_vars->value("y");
q3dgraph.cpp:265:		x->setValue(i*step-mida);
q3dgraph.cpp:267:			y->setValue(j*step-mida);
q3dgraph.cpp:268:			punts[i][j] = -a.calculate().value();
q3dgraph.cpp:274:	switch(e->key()) {
q3dgraph.cpp:306:// 	sendStatus(QString("-%1-").arg(keyspressed, 16));
q3dgraph.cpp:307:	this->repaint();
q3dgraph.cpp:311:	switch(e->key()) {
q3dgraph.cpp:345:	this->repaint();
q3dgraph.cpp:352:	this->repaint();
q3dgraph.cpp:374:	f3d.m_vars->modify("x", 0.);
q3dgraph.cpp:375:	f3d.m_vars->modify("y", 0.);
q3dgraph.cpp:386:		this->repaint();
q3dgraph.cpp:391:		this->repaint();
q3dgraph.cpp:392:		return -1;
q3dgraph.cpp:418:	this->repaint();
q3dgraph.cpp:423:	this->repaint();
q3dgraph.cpp:429:	this->repaint();
q3dgraph.cpp:435:	this->repaint();
q3dgraph.cpp:440:	return this->renderPixmap();
qalgebrahighlighter.cpp:22:					if(text[k]!=' ' && j==k-1)
qalgebrahighlighter.cpp:30:					setFormat(i+1, j-i-1, QColor(100,0,0));
qalgebrahighlighter.cpp:33:					if(Analitza::whatType(lasttag.left(lasttag.length()-1).trimmed())==Object::oper) {
qalgebrahighlighter.cpp:34:						setFormat(i+1, j-i-1, QColor(0,50,0));
qalgebrahighlighter.cpp:36:						setFormat(i+1, j-i-1, QColor(0,50,0));
qalgebrahighlighter.cpp:37:						setFormat(j-1, 1, negreta);
qalgebrahighlighter.cpp:40:					setFormat(i+1, j-i-1, QColor(150,0,0));
qalgebrahighlighter.cpp:41:					setFormat(j+1, k-j-1, QColor(150,100,0));
qalgebrahighlighter.cpp:43:					setFormat(i+1, j-i-1, QColor(150,0,0));
qalgebrahighlighter.cpp:78:		int p=-1;
qalgebrahighlighter.cpp:79:		if(m_pos>0 && (text[m_pos-1]=='(' || text[m_pos-1]==')'))
qalgebrahighlighter.cpp:80:			p=m_pos-1;
qalgebrahighlighter.cpp:84:		if(p>-1) {
qalgebrahighlighter.cpp:101:		return -1;
qalgebrahighlighter.cpp:104:			--cat;
qalgebrahighlighter.cpp:108:		p += opening ? 1 : -1;
qalgebrahighlighter.cpp:111:	p -= opening ? 1 : -1;
qalgebrahighlighter.cpp:114:		return -2;
qalgebrahighlighter.cpp:150:	} else if(a[0]=='-' && a[1] == '>') {
qalgebrahighlighter.cpp:158:	else if(a[0]=='-')
qalgebrahighlighter.cpp:184:	l-=a.length();
qalgebrahighlighter.cpp:185:// 	qDebug("%d------------", a.length());
qexp.cpp:18: *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
qexp.cpp:72://	 :=   ->  ..  +   -   *   /   ^   M   f   ,   (   )   $
qexp.cpp:74:	{ R,  S,  S,  S,  S,  S,  S,  S,  S,  S,  R,  S,  R,  R },	//-> Lambda
qexp.cpp:77:	{ R,  R,  R,  R,  K,  S,  S,  S,  S,  S,  R,  S,  R,  R },	//-
qexp.cpp:138:	} else if(a[0]=='-' && a[1] == '>') {
qexp.cpp:149:	else if(a[0]=='-')
qexp.cpp:191:// 	cout << "------>" << tokval.ascii() << "'" << endl;
qexp.cpp:245:		case tLambda: // ->
qexp.cpp:319:	return -1;
qexpressionedit.cpp:15:	this->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
qexpressionedit.cpp:16:	this->setFixedHeight(QFontMetrics(this->currentFont()).height()+12);
qexpressionedit.cpp:17:	this->setTabChangesFocus(true);
qexpressionedit.cpp:18:	this->setAcceptRichText(false);
qexpressionedit.cpp:19:	this->setAutoFormatting(AutoNone);
qexpressionedit.cpp:24:	m_helptip->setFrameShape(QFrame::Box);
qexpressionedit.cpp:25:	m_helptip->setFocusPolicy(Qt::NoFocus);
qexpressionedit.cpp:26:	m_helptip->setAutoFillBackground(false);
qexpressionedit.cpp:27:	m_helptip->hide();
qexpressionedit.cpp:29:	palette.setColor(m_helptip->backgroundRole(), QColor(255,230,255));
qexpressionedit.cpp:30:	m_helptip->setPalette(palette);
qexpressionedit.cpp:32:	m_highlight= new QAlgebraHighlighter(this->document());
qexpressionedit.cpp:35:	m_completer->setWidget(this);
qexpressionedit.cpp:37:	m_completer->setPopup(treeView);
qexpressionedit.cpp:38:	treeView->setRootIsDecorated(false);
qexpressionedit.cpp:39:	treeView->header()->hide();
qexpressionedit.cpp:40:	treeView->resizeColumnToContents(1);
qexpressionedit.cpp:41:	treeView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
qexpressionedit.cpp:42:	treeView->setMinimumWidth(300);
qexpressionedit.cpp:45:	treeView->header()->setResizeMode(0, QHeaderView::ResizeToContents);
qexpressionedit.cpp:46:// 	treeView->header()->setResizeMode(2, QHeaderView::ResizeToContents);
qexpressionedit.cpp:47:	treeView->setColumnHidden(1, true);
qexpressionedit.cpp:48:	treeView->setColumnHidden(2, true);
qexpressionedit.cpp:65:			QHash<QString, Object*>::const_iterator it = a->m_vars->begin();
qexpressionedit.cpp:66:			for(int i=m_ops->count(); it != a->m_vars->end(); ++it) {
qexpressionedit.cpp:67:				m_ops->setData(m_ops->index(i, 0), it.key());
qexpressionedit.cpp:68:// 				m_ops->setData(m_ops->index(i, 1), Analitza::treu_tags(a->str(it.value())));
qexpressionedit.cpp:69:				m_ops->setData(m_ops->index(i, 2), "var");
qexpressionedit.cpp:74:		m_completer->setModel(m_ops);
qexpressionedit.cpp:80:	int c = newText.length() - lastWord(textCursor().selectionStart()).length();
qexpressionedit.cpp:89:	QStandardItem *it = m_words->itemFromIndex(index);
qexpressionedit.cpp:92:		QString newText = it->data(0).toString();
qexpressionedit.cpp:93:		int c = newText.length() - lastWord(textCursor().selectionStart()).length();
qexpressionedit.cpp:102:	switch(m_highlight->mode()) {
qexpressionedit.cpp:108:			return Analitza::isMathML(this->toPlainText());
qexpressionedit.cpp:117:			a.setTextMML(this->toPlainText());
qexpressionedit.cpp:118:			this->setPlainText(a.toString());
qexpressionedit.cpp:121:			QExp e(this->toPlainText());
qexpressionedit.cpp:125:			this->setPlainText(e.mathML());
qexpressionedit.cpp:128:	m_highlight->setMode(en);
qexpressionedit.cpp:135:	if(!this->toPlainText().isEmpty()) {
qexpressionedit.cpp:136:		m_history.last() = this->toPlainText();
qexpressionedit.cpp:138:		m_histPos=m_history.count()-1;
qexpressionedit.cpp:146:	switch(e->key()){
qexpressionedit.cpp:152:				this->setPlainText(a.toMathML());
qexpressionedit.cpp:158:				this->setPlainText(a.toString());
qexpressionedit.cpp:159:				this->selectAll();
qexpressionedit.cpp:168:// 			qDebug() << m_completer->popup()->isVisible();
qexpressionedit.cpp:172:			if(!m_completer->popup()->isVisible()) {
qexpressionedit.cpp:178:			if(!m_completer->popup()->isVisible()) {
qexpressionedit.cpp:179:				m_histPos--;
qexpressionedit.cpp:186:			if(this->toPlainText().length() == (this->textCursor().position()-this->textCursor().anchor()) && m_auto) {
qexpressionedit.cpp:187:				this->setPlainText(m_ans);
qexpressionedit.cpp:188:				QTextCursor tc = this->textCursor();
qexpressionedit.cpp:190:				this->setTextCursor(tc);
qexpressionedit.cpp:194:			m_history.last() = this->toPlainText();
qexpressionedit.cpp:198:				int curPos = this->textCursor().position();
qexpressionedit.cpp:203:				m_completer->setCompletionPrefix(last);
qexpressionedit.cpp:204:				m_completer->complete();
qexpressionedit.cpp:207:				m_completer->popup()->hide();
qexpressionedit.cpp:216:			m_histPos=m_history.count()-1;
qexpressionedit.cpp:217:		this->setPlainText(m_history[m_histPos]);
qexpressionedit.cpp:224:	int act=pos-1;
qexpressionedit.cpp:225:	for(; act>=0 && exp[act].isLetter(); act--);
qexpressionedit.cpp:227:	return exp.mid(act+1, pos-act-1);
qexpressionedit.cpp:250:				if(param_rec != -1){
qexpressionedit.cpp:255:			} else act--;
qexpressionedit.cpp:261:			cat--;
qexpressionedit.cpp:264:				param=-1; //Means this is a useless func
qexpressionedit.cpp:267:				param=-3;
qexpressionedit.cpp:271://		qDebug("word: %s", exp.mid(act, exp.length()-act).ascii());
qexpressionedit.cpp:283:	return findPrec(this->toPlainText().mid(0,pos), p, pos, param, "");
qexpressionedit.cpp:288:	int param=0, pos=this->textCursor().position();
qexpressionedit.cpp:289:	m_highlight->setPos(pos);
qexpressionedit.cpp:294:	m_highlight->rehighlight();
qexpressionedit.cpp:301:		if(op == -1) {
qexpressionedit.cpp:312:				if(i<op-1)
qexpressionedit.cpp:317:	} else if(a!=NULL && a->m_vars->contains(funcname) && a->m_vars->value(funcname)->type()==Object::container) { //if it is a function defined by the user
qexpressionedit.cpp:318:		Container *c = (Container*) a->m_vars->value(funcname);
qexpressionedit.cpp:319:		QStringList params = c->bvarList();
qexpressionedit.cpp:330:			if(i<params.count()-1)
qexpressionedit.cpp:350:	this->setPlainText(this->toPlainText().remove('\n'));
qexpressionedit.cpp:357:	curPos=this->textCursor().position();
qexpressionedit.cpp:359:// 	pixelsOffset -= contentsX();
qexpressionedit.cpp:362:	ajudant(msg, pos-QPoint(0, 50));
qexpressionedit.cpp:368:		QFontMetrics fm(m_helptip->font());
qexpressionedit.cpp:369:		m_helptip->setText(msg);
qexpressionedit.cpp:370:		m_helptip->setGeometry(QRect(p, p+QPoint(fm.width(msg)+20, 23)));
qexpressionedit.cpp:372:		m_helptip->show();
qexpressionedit.cpp:373:		m_helptip->raise();
qexpressionedit.cpp:374:		this->setFocus();
qexpressionedit.cpp:376:		m_helptip->hide();
qexpressionedit.cpp:393:	this->setPalette(p);
qexpressionedit.cpp:399:	switch(event->reason()) {
qexpressionedit.cpp:402:			this->selectAll();
qgraph.cpp:21:	this->setFocusPolicy(Qt::ClickFocus);
qgraph.cpp:22:	this->setCursor(QCursor(Qt::CrossCursor));
qgraph.cpp:23:	this->setMinimumHeight(20);
qgraph.cpp:24:	this->setMinimumWidth(10);
qgraph.cpp:25:	this->setMouseTracking(!m_readonly);
qgraph.cpp:26:	this->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
qgraph.cpp:29:	viewport = QRect(QPoint(-12, 10), QPoint(12, -10));
qgraph.cpp:30:	this->setAutoFillBackground(false);
qgraph.cpp:64:	f->drawText(QPointF(3.+this->width()/2., 13.               ), QString::number(viewport.top()));
qgraph.cpp:65:	f->drawText(QPointF(3.+this->width()/2., this->height()-5. ), QString::number(viewport.bottom()));
qgraph.cpp:66:	f->drawText(QPointF(8.                 , this->height()/2.-5.), QString::number(viewport.left()));
qgraph.cpp:67:	f->drawText(QPointF(this->width()-30.  , this->height()/2.-5.),QString::number(viewport.right()));
qgraph.cpp:75:	w->setPen(ceixos);
qgraph.cpp:90:	w->setPen(ceixos);
qgraph.cpp:95:		QPointF p2(toWidget(QPointF(-i,-i)));
qgraph.cpp:96:		w->drawEllipse(QRectF(p.x(),p.y(), p2.x()-p.x(),p2.y()-p.y()));
qgraph.cpp:102:	w->setPen(ceixos);
qgraph.cpp:103:	w->drawLine(QPointF(0., centre.y()), QPointF(this->width(), centre.y()));
qgraph.cpp:104:	w->drawLine(QPointF(centre.x(), 0.), QPointF(centre.x(),this->height()));
qgraph.cpp:116:	finestra->setPen(ceixos);
qgraph.cpp:121:			finestra->drawLine(QPointF(p.x(), this->height()), QPointF(p.x(), 0));
qgraph.cpp:123:			finestra->drawLine(p, p+QPointF(0.,-3.));
qgraph.cpp:126:	for(x=ceil(viewport.top()); x>=viewport.bottom(); x-=1.0) {		// ralletes y
qgraph.cpp:129:			finestra->drawLine(QPointF(0., p.y()), QPointF(width(), p.y()));
qgraph.cpp:131:			finestra->drawLine(p, p+QPointF(3.,0.));
qgraph.cpp:136:	finestra->setPen(ceixos);
qgraph.cpp:139:	finestra->drawLine(QPointF(0., centre.y()), QPointF(this->width(), centre.y()));
qgraph.cpp:140:	finestra->drawLine(QPointF(centre.x(), 0.), QPointF(centre.x(),this->height()));
qgraph.cpp:149:		buffer = QPixmap(this->width(), this->height());
qgraph.cpp:215:		finestra.drawLine(QPointF(0.,ultim.y()), QPointF(this->width(), ultim.y()));
qgraph.cpp:216:		finestra.drawLine(QPointF(ultim.x(),0.), QPointF(ultim.x(), this->height()));
qgraph.cpp:220:		if(ultim.x()+w > this->width())
qgraph.cpp:221:			ultim.setX(this->width()-w);
qgraph.cpp:222:		if(ultim.y()+h > this->height())
qgraph.cpp:223:			ultim.setY(this->height()-h);
qgraph.cpp:243:	} //else micepos->hide();
qgraph.cpp:249:		QPoint p2=QPoint(this->width(), this->height());
qgraph.cpp:250:		finestra.drawRect(QRect(QPoint(0,0), p2-QPoint(2,2)));
qgraph.cpp:260:	int d = e->delta()>0 ? -1 : 1;
qgraph.cpp:261:	if(viewport.left()-d < 1 && viewport.top()+d > 1 && viewport.right()+d > 1 && viewport.bottom()-d < 1) {
qgraph.cpp:262:		viewport.setLeft(viewport.left() - 1.);
qgraph.cpp:265:		viewport.setBottom(viewport.bottom() - 1.);
qgraph.cpp:269:	sendStatus(QString("(%1, %2)-(%3, %4)").arg(viewport.left()).arg(viewport.top()).arg(viewport.right()).arg(viewport.bottom()));
qgraph.cpp:273:// 	qDebug("%d", toViewport(e->pos()).x());
qgraph.cpp:274:	if(!m_readonly && (e->button()==Qt::LeftButton || e->button()==Qt::MidButton)) {
qgraph.cpp:275:		last = press = e->pos();
qgraph.cpp:276:		ant = toViewport(e->pos());
qgraph.cpp:277:		this->setCursor(QCursor(Qt::PointingHandCursor));
qgraph.cpp:278:		if(e->button()==Qt::MidButton || (e->button()==Qt::LeftButton && e->modifiers()&Qt::ControlModifier))
qgraph.cpp:280:		else if(e->button()==Qt::LeftButton)
qgraph.cpp:287:	this->setCursor(QCursor(Qt::CrossCursor));
qgraph.cpp:289:		QPointF pd = toViewport(press) - toViewport(e->pos());
qgraph.cpp:299:		QPointF p=toViewport(e->pos())+viewport.topLeft();
qgraph.cpp:319:		sendStatus(QString("(%1, %2)-(%3, %4)").arg(viewport.left()).arg(viewport.top()).arg(viewport.right()).arg(viewport.bottom()));
qgraph.cpp:322:	this->repaint();
qgraph.cpp:327:	mark=calcImage(fromWidget(e->pos()));
qgraph.cpp:329:	if(!m_readonly && mode==Pan && ant != toViewport(e->pos())){
qgraph.cpp:330:		QPointF rel = toViewport((e->pos() - press - (toWidget(QPointF(.5,.5))-toWidget(QPointF(0.,0.)))).toPoint());
qgraph.cpp:331:		viewport.setLeft(viewport.left() - rel.x()); viewport.setRight(viewport.right() - rel.x());
qgraph.cpp:332:		viewport.setTop(viewport.top() - rel.y()); viewport.setBottom(viewport.bottom() - rel.y());
qgraph.cpp:335:		press = e->pos();
qgraph.cpp:336:		ant = toViewport(e->pos());
qgraph.cpp:338:		sendStatus(QString("(%1, %2)-(%3, %4)").arg(viewport.left()).arg(viewport.top()).arg(viewport.right()).arg(viewport.bottom()));
qgraph.cpp:339:	} else if(e->buttons()&Qt::LeftButton) {
qgraph.cpp:340:		last = e->pos();
qgraph.cpp:341:	} else if(e->buttons()==0)
qgraph.cpp:344:	this->repaint();
qgraph.cpp:350:	switch(e->key()) {
qgraph.cpp:356:			viewport.setLeft(viewport.left() -step);
qgraph.cpp:357:			viewport.setRight(viewport.right() -step);
qgraph.cpp:360:			viewport.setTop(viewport.top() -step);
qgraph.cpp:361:			viewport.setBottom(viewport.bottom() -step);
qgraph.cpp:369:			viewport.setCoords(viewport.left() -1., viewport.top() +1., viewport.right() + 1., viewport.bottom() -1.);
qgraph.cpp:373:			if(viewport.height() < -3. && viewport.width() > 3.){
qgraph.cpp:375:// 				resolucio=(resolucio*viewport.width())/(viewport.width()-2.);
qgraph.cpp:376:				viewport.setCoords(viewport.left() + 1., viewport.top() -1., viewport.right() -1., viewport.bottom() +1.);
qgraph.cpp:385:	this->repaint();
qgraph.cpp:451:	this->repaint();
qgraph.cpp:466:	this->repaint();
qgraph.cpp:475:	this->repaint();
qgraph.cpp:487:	this->repaint();
qgraph.cpp:493:	return QPointF((-viewport.left() + p.x()) * rang_x,  (-viewport.top() + p.y()) * rang_y);
qgraph.cpp:498:	double part_negativa_x = -viewport.left();
qgraph.cpp:499:	double part_negativa_y = -viewport.top();
qgraph.cpp:500:	return QPointF(p.x()/rang_x-part_negativa_x, p.y()/rang_y-part_negativa_y);
qgraph.cpp:534:	buffer=QPixmap(this->size());
qgraph.cpp:567:		this->repaint();
value.cpp:18: *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
value.cpp:26:	if(o->type()==Operator::value){
value.cpp:28:		m_value = v->value();
value.cpp:29:		m_boolean = v->isBoolean();
value.cpp:30:		setCorrect(v->isCorrect());
value.cpp:49:		else if(val.attribute("type") == "e-notation")		ret = real;
value.cpp:51:		else if(val.attribute("type") == "complex-cartesian")	ret = none;
value.cpp:52:		else if(val.attribute("type") == "complex-polar")	ret = none;
value.cpp:75:	this->m_vformat=whatValueFormat(val);
value.cpp:86:		else if(val.attribute("type") == "e-notation")	{ /*TODO: Not implemented */ }
value.cpp:88:		else if(val.attribute("type") == "complex-cartesian")	{ /*TODO: Not implemented */ }
value.cpp:89:		else if(val.attribute("type") == "complex-polar")	{ /*TODO: Not implemented */ }
variables.cpp:18: *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
variables.cpp:34:	for (i = this->begin(); i != this->end(); i++) {
variables.cpp:42:	for (i = this->begin(); i != this->end(); i++)
